---
typora-root-url: ./
---

## 设计模式的分类

所有模式可以根据其意图或目的来分类。 本书覆盖了三种主要的模式类别：

- **创建型模式**提供创建对象的机制， 增加已有代码的灵活性和可复用性。

  - 简单工厂模式（Simple Factory）

    重要程度：4 （5为满分）

  - 工厂方法模式（Factory Method）

    重要程度：5

  - 抽象工厂模式（Abstract Factory）

    重要程度：5

  - 建造者模式（Builder）

    重要程度：2

  - 原型模式（Prototype）

    重要程度：3

  - 单例模式（Singleton）

    重要程度：4

- **结构型模式**介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。

  - **类结构型模式**关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系
  - **对象结构型模式**关心类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。根据“合成复用原则”，在系统中尽量使用关联关系来替代继 承关系，因此大部分结构型模式都是对象结构型模式。

  包含模式：

  - 适配器模式(Adapter)

    重要程度：4

  - 桥接模式(Bridge)

    重要程度：3

  - 组合模式(Composite)

    重要程度：4

  - 装饰模式(Decorator)

    重要程度：3

  - 外观模式(Facade)

    重要程度：5

  - 享元模式(Flyweight)

    重要程度：1

  - 代理模式(Proxy)

    重要程度：4

  

- **行为模式**负责对象间的高效沟通和职责委派。

## UML类图

![uml_class_struct](/_static/uml_class_struct.jpg)

类图中各个类之间的关系：

- **泛化关系**(generalization)，如：SUV与小汽车。

  最终代码中，泛化关系表现为**继承非抽象类**。

  用一条带空心箭头的实线表示。

- **实现关系**(realize)，如：小汽车与车。

  最终代码中，实现关系表现为**继承抽象类**。

  用一条带空心箭头的虚线表示。

- **聚合关系(**aggregation)，用于表示实体对象之间的关系，表示整体由部分构成的语义，但整体和部分不是强依赖的，即使整体不存在了，部分仍然存在。

  如：部门由多个员工组成。

  用一条带空心菱形箭头的直线表示。

- **组合关系**(composition)，同样表示整体由部分构成的语义，但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了。

  如：公司由多个部门组成。

  用一条带实心菱形箭头直线表示。

- **关联关系**(association)，一般用来定义对象之间静态的、天然的结构，是一种“强关联”的关系。可以强调方向。

  如：乘车人与车票。

  最终代码中，关联对象通常是以成员变量的形式实现的。

  用一条直线表示。

- **依赖关系**(dependency)，描述一个对象在运行期间会用到另一个对象。与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化， 依赖关系也可能发生变化。双向依赖很糟糕，应该保持单向依赖。

  如：学生上学需要自行车。

  在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系。

  用一套带箭头的虚线表示。

## 时序图

时序图（Sequence Diagram）是显示对象之间交互的图，这些对象是按时间顺序排列的。时序图中显示的是参与交互的对象及其对象之间消息交互的顺序。

时序图包括的建模元素主要有：对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等等。

参考：https://www.cnblogs.com/a311300/p/4094547.html

## 简单工厂模式( Simple Factory Pattern )

简单工厂模式(Simple Factory Pattern)：又称为**静态工厂**方法(Static Factory Method)模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

模式结构：

- Factory：工厂角色

  工厂角色负责实现创建所有实例的内部逻辑，相当于**用户接口**，提供**静态方法**，根据不同参数创建不同实例。

- Product：抽象产品角色

  抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的**公共接口**

- ConcreteProduct：具体产品角色

  具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。**继承Product，实现具体细节**

模式分析：

- 将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。
- 使用简单，只需传参。
- 缺点：工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑

适用情况：

- 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
- 客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。

##  工厂方法模式(Factory Method Pattern)

工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式。

工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。

模式结构：

- Product：抽象产品
- ConcreteProduct：具体产品
- Factory：抽象工厂
- ConcreteFactory：具体工厂

模式分析：

- 使用了面向对象的多态性，保持了简单工厂模式的优点，而且克服了它的缺点。核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。可以允许系统在不修改工厂角色的情况下引进新产品。
- 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。

- 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度

## 抽象工厂模式(Abstract Factory)

抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式。

模式结构：

- AbstractFactory：抽象工厂
- ConcreteFactory：具体工厂
- AbstractProduct：抽象产品
- Product：具体产品

模式分析：

- 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。

- 加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。
- 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。

## 建造者模式(Builder Pattern)

造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。

模式结构：

- Builder：抽象建造者
- ConcreteBuilder：具体建造者
- Director：指挥者
- Product：产品角色

模式分析：

抽象建造者类中定义了产品的创建方法和返回方法;

建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象

在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。

## 单例模式(Singleton Pattern)

单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。

单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。

模式结构：

- Singleton：单例

模式分析：

- 单例模式包含的角色只有一个，就是单例类——Singleton。单例类拥有一个**私有构造函数**，确保用户无法通过new关键字直接实例化它。
- 包含一个**静态私有成员变量**与**静态公有的工厂方法**，该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。

优点：

- 对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。

缺点：

- 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。
- 单例类的职责过重，在一定程度上违背了“单一职责原则”。将产品的创建和产品的本身的功能融合到一起。

适用环境：

- 在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式

两种实现：

- 饿汉式单例模式：在单例类被加载时候，就实例化一个对象并交给自己的引用。

  立即加载

  天生就是线程安全的

- 懒汉式单例模式：只有在真正使用的时候才会实例化一个对象并交给自己的引用。

  延迟加载

  非线程安全的

## 适配器模式(Adapter Pattern)

将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作。又称为包装器(Wrapper)。

模式结构：

- Target：目标抽象类，定义Client需要的接口，Adapter需要继承此类。
- Adapter：适配器类，**封装Adaptee**，提供Client需要的**接口实现**。
- Adaptee：适配者类，被包装的类，通常此类的接口不兼容Client，所以需要包装。
- Client：客户类，针对Target编程，调用具体的方法。

适配器模式有对象适配器和类适配器两种实现：

- 对象适配器模式：适配器类继承了目标抽象类并包含多个适配者对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。
- 类适配器模式：适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类的实现方法中调用所继承的适配者类的方法。

优点：：

- 通过引入一个适配器类来封装现有的适配者类，而无须修改原有代码。
- 对象适配器模式：可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。
- 类适配器模式：一个适配器可以把适配者类和它的子类都适配到目标接口。

缺点：

- 对象适配器模式：相比类适配器模式，要想置换适配者类的方法更难。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。

- 类适配器模式：对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者。

适用环境：

- 系统需要使用现有的类，而这些类的接口不符合系统的需要。
- 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。
- 比如某些数据库标准接口和不同厂家的数据库引擎之间，需要数据库驱动作为适配器。

## 桥接模式(Bridge Pattern)

将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。

桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。

模式结构：

- Abstraction：抽象类
- RefinedAbstraction：扩充抽象类，继承抽象类，实现和扩充由抽象类定义的接口
- Implementor：实现类接口
- ConcreteImplementor：具体实现类，继承实现类，实现实现类接口，提供给客户端具体的业务操作方法。

优点：

- 桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。
- 桥接模式提高了系统的可扩充性，在**两个变化维度中任意扩展**一个维度，都不需要修改原有系统。

缺点：

- 桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。
- 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。

